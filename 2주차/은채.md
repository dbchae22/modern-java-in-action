# 동작 파라미터화 코드
우리가 어떤 상황에서 일을 하든 소비자 요구사항은 항상 바뀐다.  
동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.  
이는 실행 방법을 미리 확정하지 않고, 나중에 호출할 수 있도록 남겨둔 코드 블록을 뜻한다.

### 동작 파라미터화가 적용되지 않은 메서드
“색깔로 걸러낼지, 무게로 걸러낼지”를 결정하는 플러그 변수를 둔 코드이다.
```java
public static List<Apple> filterApples(List<Apple> inventory, Color color,
                                       int weight, boolean flag) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if ((flag && apple.getColor().equals(color)) ||
            (!flag && apple.getWeight() > weight)) {
            result.add(apple);
        }
    }
    return result;
}
```
아래처럼 위 메서드를 사용할 수 있다.
```java
List<Apple> greenApples = filterApples(inventory, GREEN, 0, true);
List<Apple> heavyApples = filterApples(inventory, null, 150, false);
```

위 코드는 형편없는 코드다.
게다가 앞으로 요구사항이 바뀌었을 때 유연하게 대응할 수도 없다.  
예를 들어 사과의 크기, 모양, 출하지 등으로 사과를 필터링하고 싶다면 어떻게 될까?  
결국 여러 중복된 필터 메서드를 만들거나 아니면 모든 것을 처리하는 거대한 하나의 필터 메서드를 구현해야 한다.  

## 프레디케이트
참 또는 거짓을 반환하는 함수
```java
public interface ApplePredicate {
    boolean test(Apple apple);
}
```
입력값: Apple 객체  
출력값: true or false

ApplePredicate라는 인터페이스를 하나 정의해 두면, 그걸 구현한 여러 버전(구현체)을 만들 수 있다.
```java
// 초록색 사과만 선택
class AppleGreenColorPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return GREEN.equals(apple.getColor());
    }
}

// 무거운 사과만 선택
class AppleHeavyWeightPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return apple.getWeight() > 150;
    }
}
```
filter 메서드 자체의 구조는 같지만, 어떤 조건(프레디케이트)을 넘기느냐에 따라 결과가 달라진다.  
즉, 초록색 사과 조건을 주면 초록색만 걸러지고, 무거운 사과 조건을 주면 무거운 것만 걸러지는 식으로, 조건에 따라서 같은 filter 메서드가 다른 방식으로 작동한다.  
이를 '전략 디자인 패턴'이라고 부른다.

## 전략 디자인 패턴
어떤 알고리즘(전략)을 인터페이스로 정의하고, 구체적인 전략을 객체로 캡슐화해서 상황에 따라 교체할 수 있도록 하는 패턴  
Java 8 이전: 전략 패턴을 쓰려면 인터페이스 + 구현 클래스를 계속 만들어야 했다.  
Java 8 이후: Predicate<T> 라는 함수형 인터페이스가 이미 제공되고, 람다식으로 바로 전략을 주입할 수 있다.

## 프레디케이드를 이용한 필터 메서드
다음은 위에서 만들었던 ApplePredicate를 이용한 필터 메서드다.
```java
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}

List<Apple> greenApples = filterApples(inventory, new AppleGreenColorPredicate());

```
위 코드처럼 '컬렉션 탐색 로직'과 '각 항목에 적용할 동작'을 분리할 수 있다는 것이 동작 파라미터화의 강점이다.  
한 메서드가 다른 동작을 수행하도록 재활용할 수 있기 때문에 유연한 API를 만들 때 동작 파라미화가 중요한 역할을 한다.  
  
하지만 현재 filterApples 메서드로 새로운 동작을 전달하려면 ApplePredicate 인터페이스를 구현하는 여러 클래스를 정의한 다음에 인스턴스화해야 한다.  
이는 상당히 번거로운 작업이며 시간 낭비다.  
자바는 클래스의 선언과 인스턴스화를 동시에 수행할 수 있도록 '익명 클래스'라는 기법을 제공한다.  

## 익명 클래스
익명 클래스는 말 그대로 이름이 없는 클래스다.  
익명 클래스를 이용하면 클래스 선언과 인스턴스화를 동시에 할 수 있다.  
즉, 즉석에서 필요한 구현을 만들어서 사용할 수 있다.  
```java
//빨간 사과만 필터링
**`List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
    public boolean test(Apple apple) {`**
        return "red".equals(apple.getColor());
    }
});
```

### 이벤트 핸들러 객체
사용자의 입력이나 시스템에서 발생하는 사건을 처리하기 위해 작성된 객체  
이벤트 핸들러 객체를 구현할 때 익명 클래스를 종종 사용한다.
```java
**`button.setOnAction(new EventHandler<ActionEvent>() {
  public void handle(ActionEvent event){`**
    System.out.println("Who a click!");
  }
}
```

하지만 익명 클래스로도 아직 부족한 점이 있다.  
1. 많은 공간을 차지한다.  
2. 많은 프로그래머가 익명 클래스의 사용에 익숙하지 않다.  
익명 클래스를 쓰면 코드 안에서 바로 조건을 정의할 수 있긴 하지만, 결국 새로운 객체를 만들고 test 메서드를 구현해야 한다는 점은 똑같이 귀찮다.  
  
자바 8 에서는 '람다 표현식'이라는 더 간단한 코드 전달 기법을 도입해서 이 문제를 해결했다.  

## 람다 표현식
람다 표현식은 익명 클래스를 간단히 표현하는 문법이다.
```java
(매개변수) -> { 실행 코드 }
```
형태로 쓸 수 있다.

#### 기존 방식
어떤 동작(조건, 계산 등)을 전달하려면 반드시 클래스를 만들고 메서드를 구현해야 했다.
```java
Predicate<String> isEmpty = new Predicate<String>() {
    public boolean test(String s) {
        return s.isEmpty();
    }
};
```

#### 람다식
함수형 인터페이스의 구현을, 짧은 문법으로 바로 작성할 수 있게 해준다.
```java
Predicate<String> isEmpty = s -> s.isEmpty();
```
  
위에서 작성했던 빨간 사과 필터링을 다음과 같이 람다식으로 간단하게 표현할 수 있다.
```java
List<Apple> redApples = filterApples(inventory,
                                     apple -> "red".equals(apple.getColor()));
```
  
이제 제네릭 필터 메서드를 만들어서 어떤 리스트든(사과, 오렌지, 정수, 문자열 …) 조건만 바꿔서 걸러낼 수 있다.
```java
//'Hello'로 시작하는 단어만 필터링
List<String> helloStrings =
    filter(words, (String s) -> s.startsWith("Hello"));

//짝수만 필터링
List<Integer> evenNumbers =
    filter(numbers, (Integer i) -> i % 2 == 0);
```

### 자바 API의 많은 메서드를 다양한 동작으로 파라미터화할 수 있다.
1. Comparator로 정렬하기
```java
//사과를 무게가 적은 순서로 목록에서 사과를 정렬하기
inventory.sort(
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
```

2. Runnable/Callable
  1) 개념  
  - **Runnable / Callable** 은 실행할 **"코드 블록"** 을 표현하는 함수형 인터페이스이다.  
  - 공통점: 코드 자체를 값처럼 다루어 **메서드 파라미터로 전달**할 수 있다.  
  - 차이점:  
    - Runnable → `void run()` : 실행만, 결과 ❌  
    - Callable → `V call()` : 실행 + 결과 반환 ⭕, 예외 처리 ⭕  
      +) ExecutorService를 이용하면 태스크를 스레드 풀로 보내고 결과를 Future로 저장할 수 있다. 

  2) 실행 주체  
  - Runnable / Callable 은 **스스로 실행 능력이 없다.**  
  - 단순히 "무엇을 할지"만 정의해둔 코드 조각일 뿐.  
  - 실제 실행은 **Thread** 나 **Executor(스레드 풀)** 같은 실행기(런타임 환경)가 담당한다.  

  3) 람다식 표현
  ```java
  //Runnable
  Thread t = new Thread(() -> System.out.println("Hello!"));

  //Callable
  Future<String> threadName = executorService.submit(() -> Thread.currentThread().getName());
  ```


3. GUI 이벤트 처리하기  
일반적으로 GUI 프로그래밍은 마우스 클릭이나 문자열 위로 이동하는 등의 이벤트에 대응하는 동작을 수행하는 식으로 동작한다.  
GUI 프로그래밍에서도 변화에 대응할 수 있는 유연한 코드가 필요하다.  
자바FX에서는 setOnAction 메서드에 EventHandler를 전달함으로써 이벤트에 어떻게 반응할지 설정할 수 있다.  
> - `setOnAction` 메서드는 버튼 클릭 이벤트에 실행할 동작을 설정하는 역할을 한다.    
> - `EventHandler`는 그 동작을 표현하는 방법(인터페이스)이다.  
```java
button.setOnAction((ActionEvent event) -> label.setText("Sent!"));
```
