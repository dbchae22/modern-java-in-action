## 메서드 참조(Method Reference)

람다식이 기존 메서드를 그대로 호출만 하는 경우, 그 메서드의 이름을 직접 참조해서 쓸 수 있는 문법이다.

```java
(x) -> ClassName.method(x)
```

```java
ClassName::method
```

즉, 람다식이 특정 메서드 하나만 호출하는 형태라면, 그 메서드를 `::` 으로 직접 참조해 더 간결하게 표현할 수 있다.

---

## 메서드 참조의 주요 형태

### 1️⃣ 정적 메서드 참조
👉 클래스의 static 메서드를 참조할 때 사용한다.

```java
Function<String, Integer> f1 = s -> Integer.parseInt(s);
Function<String, Integer> f2 = Integer::parseInt;
```

문자열을 정수로 변환하는 정적 메서드를 직접 참조한 것이다.

---

### 2️⃣ 특정 객체의 인스턴스 메서드 참조
👉 이미 생성된 객체의 인스턴스 메서드를 참조할 때 사용한다.

```java
Apple apple = new Apple(150);
Supplier<Integer> s1 = () -> apple.getWeight();
Supplier<Integer> s2 = apple::getWeight;
```

**apple::getWeight** → 특정 객체 `apple` 의 메서드 호출을 그대로 참조.

---

### 3️⃣ 특정 타입의 임의 객체 인스턴스 메서드 참조
👉 주어진 타입의 인스턴스 메서드를 참조하며, 실제 호출 대상은 매개변수로 전달된다.

```java
Function<String, Integer> f1 = s -> s.length();
Function<String, Integer> f2 = String::length;
```

**String::length** → `(String s) -> s.length()` 와 동일.

> “String 타입 객체의 length 메서드를 참조한다”는 의미.

---

### 4️⃣ 생성자 참조 (Constructor Reference) 
👉 객체를 생성하는 코드를 참조할 때 사용한다.

```java
Supplier<Apple> s = Apple::new;
Function<Integer, Apple> f = Apple::new;
BiFunction<String, Integer, Apple> bf = Apple::new;
```

생성자의 매개변수 형태에 따라 `Supplier`, `Function`, `BiFunction` 등과 매칭된다.

---

### 5️⃣ 배열 생성자 참조 (Array Constructor Reference)

```java
Function<Integer, int[]> arr = int[]::new;
```

int[]::new 은 “주어진 길이의 int 배열을 생성하라”는 의미이며,
(length) -> new int[length] 와 동일하다.

---

## ⚙️ 특징 및 유의점

* 메서드 참조는 **람다식을 더 짧게 쓴 표현**일 뿐, 실행 방식은 동일하다.
* 참조할 메서드의 **매개변수·반환 타입**이 함수형 인터페이스의 시그니처와 **일치해야 한다.**
* Class::instanceMethod 형태는 실제로 (obj1, obj2) -> obj1.instanceMethod(obj2) 처럼 해석된다. → 첫 번째 인자가 메서드를 호출할 객체가 된다.
* 참조 대상이 모호하면 컴파일러가 타입을 유추할 수 없으므로, 문맥(함수형 인터페이스 타입) 이 명확해야 한다.

---

# 🧩 점진적 리팩터링 (람다식 → 메서드 참조)

사과(Apple) 리스트를 **무게(weight)** 기준으로 정렬하는 과정을 단계별로
개선한 예시.

------------------------------------------------------------------------

## 1️⃣ 익명 클래스 사용

``` java
inventory.sort(new Comparator<Apple>() {
    @Override
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

자바 7까지 흔히 쓰던 방식이다.\
`Comparator` 인터페이스를 익명 클래스로 구현해 비교 로직을 작성한다.\
하지만 코드가 길고, 불필요한 문법 요소가 많아 가독성이 떨어진다.

------------------------------------------------------------------------

## 2️⃣ 람다 표현식 도입

``` java
inventory.sort((Apple a1, Apple a2) ->
    a1.getWeight().compareTo(a2.getWeight()));
```

익명 클래스를 **함수형 표현식(람다)** 으로 바꾼 단계다.\
`Comparator` 는 추상 메서드 하나만 가지므로 람다로 대체 가능하다.\
이제 코드가 훨씬 짧고 명확해졌다.

------------------------------------------------------------------------

## 3️⃣ 타입 추론 적용

``` java
inventory.sort((a1, a2) ->
    a1.getWeight().compareTo(a2.getWeight()));
```

컴파일러가 `Comparator<Apple>` 타입을 이미 알고 있으므로,\
매개변수의 타입(`Apple`)을 생략해도 된다.\
**코드 구조는 동일하지만**, 표현이 더 간결해진 단계다.

------------------------------------------------------------------------

## 4️⃣ `Comparator.comparing` 사용

``` java
import static java.util.Comparator.comparing;

inventory.sort(comparing(a -> a.getWeight()));
```

비교 로직을 직접 작성하지 않고, `comparing` 메서드를 사용해 '무게 기준으로 정렬하라'는 의도를 명확히 표현할 수 있다."\

즉, "정렬을 **어떻게 수행할지**"가 아니라 "**무엇을 기준으로 정렬할지**"만 명시하는 방식이다.

------------------------------------------------------------------------

### 💡 이것이 바로 **선언적 API(Declarative API)**

**선언적 API**란\
\> *'무엇을 할지(what)'* 를 표현하고,\
\> *'어떻게 수행되는지(how)'* 는 API 내부에서 처리하도록 맡기는
방식이다.

`Comparator.comparing` 은 비교 과정의 세부 절차를 숨기고\
"무게 기준으로 정렬하라"는 **의도만** 드러낸다.\
그래서 코드가 간결하고 읽는 사람이 목적을 즉시 이해할 수 있다.

------------------------------------------------------------------------

### ⚙️ 반대 개념 --- **명령형 API(Imperative API)**

**명령형 API**는\
\> 개발자가 프로그램의 동작 절차를 일일이 지시하는 방식이다.

예를 들어 다음 코드는 "어떻게 정렬할지"를 직접 구현한다.

``` java
inventory.sort(new Comparator<Apple>() {
    @Override
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

명령형 방식은 세밀한 제어가 가능하지만,\
코드가 장황해지고 **의도가 흐릿하게 보인다.**

------------------------------------------------------------------------

## 5️⃣ 메서드 참조 적용

``` java
inventory.sort(comparing(Apple::getWeight));
```

**설명:**\
람다 `(a -> a.getWeight())` 는 내부에서 **메서드 하나만 호출**하므로\
`Apple::getWeight` 형태로 단축 가능하다.\
이 단계에서 코드가 가장 간결하고, 읽는 사람이 의도를 즉시 파악할 수
있다.

------------------------------------------------------------------------

점진적 리팩터링의 핵심은 "불필요한 구조를 줄이고, **의도를 드러내는 선언적 코드**로 발전시키는 과정"이다.

## 3.8 람다 표현식 조합과 유용한 메서드

자바 8 이후에는 Predicate, Function, Comparator 같은 함수형 인터페이스에 디폴트(default) 메서드와 정적(static) 메서드가 추가되었다.
이 덕분에 개발자는 여러 람다식을 조합하거나 연결해서 복잡한 조건, 변환, 정렬 로직을 짧고 선언적으로 표현할 수 있다.

---

### 🔸 Comparator 조합 — 여러 정렬 기준 연결

```java
inventory.sort(
    comparing(Apple::getWeight)
        .reversed()
        .thenComparing(Apple::getColor)
);
```

> “무게가 무거운 순으로 정렬하고, 무게가 같으면 색상으로 정렬하라.”

* `reversed()` → 정렬 순서를 반대로.
* `thenComparing()` → 첫 기준이 같을 때 다음 기준 적용.
즉, 개발자가 정렬 로직을 직접 작성하지 않고 “무엇을 기준으로 정렬할지” 만 선언적으로 표현하는 방식이다.
---

### 🔸 Predicate 조합 — 조건식을 함수처럼 결합

```java
Predicate<Apple> red = a -> "RED".equals(a.getColor());
Predicate<Apple> heavy = a -> a.getWeight() > 150;
Predicate<Apple> green = a -> "GREEN".equals(a.getColor());

Predicate<Apple> redAndHeavyOrGreen = red.and(heavy).or(green);
```

> “빨간색이면서 무거운 사과 또는 초록색 사과” 조건을 한 줄로 표현 가능.

* `and()` → 두 조건 모두 참.
* `or()` → 둘 중 하나라도 참.
* `negate()` → 결과 반전.

이처럼 조건식을 조합하면 복잡한 if 문 없이 복잡한 조건을 한 줄로 표현할 수 있다. 즉, 조건을 데이터처럼 다루고 조립할 수 있는 방식이다.

---

### 🔸 Function 조합 — 함수 실행 순서 연결

```java
Function<Apple, String> desc = Apple::getColor;
Function<String, Integer> len = String::length;

Function<Apple, Integer> colorLen = desc.andThen(len);
```
Function은 입력값을 변환하는 함수형 인터페이스다. andThen() 은 앞 함수의 결과를 다음 함수의 입력으로 전달하며, compose()는 그 반대 순서로 실행한다.

실행 순서:

1. `desc` → 사과 색상 반환 ("GREEN")
2. `len` → 문자열 길이 계산 (5)
3. `colorLen` → 두 단계 연결 결과 5 반환

> 함수 여러 개를 **파이프라인처럼 연결**해 처리 가능. 이 개념은 Stream API의 `map → filter → collect` 로 확장된다.



질문: 반대로 명령형 코드가 더 유리한 상황은 언제일까?
